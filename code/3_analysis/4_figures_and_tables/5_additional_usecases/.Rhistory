return(HMP::Xdc.sevsample(x)$`p value`)
}
wrapper_run_HMP_Xmcupo.sevsample <- function(i){
x = readRDS(i)
x = x[[1]]@count_matrices_all
return(HMP::Xmcupo.sevsample(x)$`p value`)
}
plot_ternary <- function(x, legend_on=T, plot_points=T, ...){
require(Ternary)
if(ncol(x) != 3){stop('Number of columns must be three. Create a subcomposition or amalgamation if needed.')}
TernaryPlot(atip = colnames(x)[1], btip = colnames(x)[2], ctip = colnames(x)[3],
grid.lines = 0, grid.col = NULL, ...)
dens <- TernaryDensity(x, resolution = 10L)
cls_legend = rbind(viridisLite::viridis(48L, alpha = 0.6),
seq(from = 0, to = 47, by=1))
if(legend_on){
legend(x=-0.4,y=1.08,
fill = cls_legend[1,][c(T,F,F,F,F)],
legend = round(as.numeric(cls_legend[2,][c(T,F,F,F,F)])/sum(dens['z',]), 2), ncol=5,
y.intersp=0.8,x.intersp=0.5,text.width=0.1, cex=0.9, bty = "n")
}
ColourTernary(dens)
if(plot_points)  TernaryPoints(x, col = 'red', pch = '.', cex=5)
TernaryDensityContour(x, resolution = 30L)
}
split_matrix_in_half <- function(x){
list(x[1:(nrow(x)/2),],
x[(1+(nrow(x)/2)):nrow(x),])
}
createBarplot <- function(matrix_exposures, angle_rotation_axis = 0, order_labels=NULL,
remove_labels=FALSE, levels_signatures=NULL, includeMelt=NULL,
Melt=NULL, verbose=TRUE, arg_title='Signature', reorder_sigs=NULL,
custom_color_palette=NULL){
#' error due to it not being a matrix:
#'    No id variables; using all as measure variables
#'    Rerun with Debug
#'    Error in `[.data.frame`(.mat, , "Var1") : undefined columns selected \\
#' (use tomatrix())
if(is.null(colnames(matrix_exposures))) stop('columns must have names')
require(reshape2)
require(ggplot2)
library(RColorBrewer)
if(verbose){
cat(paste0('Creating plot... it might take some time if the data are large. Number of samples: ', nrow(matrix_exposures), '\n'))
}
if( (!is.null(order_labels) & typeof(order_labels) == "logical")){if(!order_labels){cat('WARNING: Order labels is either a vector with desired order or NULL, not bool')}}
if(!is.null(levels_signatures)){
library(ggthemes)
ggthemes_data$economist
}else{
levels_signatures <- colnames(matrix_exposures)
}
if(is.null(custom_color_palette)){
n <- 60
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unique(unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals))))
col_vector <- c(col_vector[c(T,F)], col_vector[c(F,T)])
myColors <- col_vector[1:length(levels_signatures)]
names(myColors) <- levels_signatures
myColors <- myColors[levels_signatures %in% unique(colnames(matrix_exposures))]
}else{
myColors <- custom_color_palette
}
if(is.null(order_labels)) order_labels = rownames(matrix_exposures)
if(!is.null(includeMelt)){
cat('For whatever reason sometimes the melt does not work. Here it is passed as argument.')
.mat <- Melt
}else{
.mat <- melt(matrix_exposures)
}
.mat[,'Var1'] <- factor(.mat[,'Var1'], levels=order_labels)
.mat[,'Var2'] <- factor(.mat[,'Var2'], levels=levels_signatures)
###rownames(.mat) <- rownames(matrix_exposures) ### new
if(!is.null(reorder_sigs)){
### if we want signatures to be re-ordered, but for them to have a common colour scheme,
## use reorder_sigs together with levels_signatures, where levels_signatures creates a
## common colour scheme, and reorder_sigs changes the order of the bars
levels_signatures <- reorder_sigs
}
if(!remove_labels){
if(!is.null(levels_signatures)){
ggplot(.mat, aes(x=Var1, y=value, fill=factor(Var2, levels=levels_signatures[levels_signatures %in% unique(colnames(matrix_exposures))])))+
geom_bar(stat = 'identity')+
theme(axis.text.x = element_text(angle = angle_rotation_axis, hjust = 1))+
#theme(axis.title.x=element_blank(),
#      axis.text.x=element_blank(),
#      axis.ticks.x=element_blank())+
guides(fill=guide_legend(title=arg_title))+
scale_fill_manual(name = "grp",values = myColors)
}else{
ggplot(.mat, aes(x=Var1, y=value, fill=factor(Var2, levels=levels_signatures)))+
geom_bar(stat = 'identity')+
theme(axis.text.x = element_text(angle = angle_rotation_axis, hjust = 1))+
#theme(axis.title.x=element_blank(),
#      axis.text.x=element_blank(),
#      axis.ticks.x=element_blank())+
guides(fill=guide_legend(title=arg_title))
}
}else{
if(!is.null(levels_signatures)){
ggplot(.mat, aes(x=Var1, y=value, fill=factor(Var2, levels=levels_signatures)))+
geom_bar(stat = 'identity')+
theme(axis.text.x = element_text(angle = angle_rotation_axis, hjust = 1))+
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank())+
guides(fill=guide_legend(title=arg_title))+
scale_fill_manual(name = "grp",values = myColors)
}else{
ggplot(.mat, aes(x=Var1, y=value, fill=factor(Var2, levels=levels_signatures)))+
geom_bar(stat = 'identity')+
theme(axis.text.x = element_text(angle = angle_rotation_axis, hjust = 1))+
theme(axis.title.x=element_blank(),
axis.text.x=element_blank(),
axis.ticks.x=element_blank())+
guides(fill=guide_legend(title=arg_title))
}
}
}
give_min_pert <- function(idx_sp, list_runs=diagRE_DMDL_nonexo_SP, logR_names_vec=logR_nonexo_notsorted_SP,
df_betas=NULL){
require(dplyr)
if(!is.null(df_betas)){
## get betas from df
.summary_betas_slope_SP <- df_betas
.slopes_minpert_SP <- .summary_betas_slope_SP[,1]
}else{
## get betas from TMB output
.betas_SP <- data.frame(plot_betas(list_runs[[idx_sp]], names_cats= logR_names_vec[[idx_sp]],
return_df=T, plot=F))
.slopes_minpert_SP <- .betas_SP %>% dplyr::filter(type_beta == "Slope") %>% dplyr::select(Estimate) %>% unlist()
# print(.slopes_minpert_SP)
## check if the CI of the betas touches this median value
.summary_betas_slope_SP <- python_like_select_rownames(summary(list_runs[[idx_sp]]), 'beta')[c(F,T),]
nrow(.summary_betas_slope_SP)
}
minimal_change_baseline <- median(c(.slopes_minpert_SP, 0))
# print(.summary_betas_slope_SP)
# print(logR_nonexo_notsorted_SP[[idx_sp]])
# print(dim(.summary_betas_slope_SP))
if(!is.null(dim(.summary_betas_slope_SP))){
.params_in_ci <- give_params_in_CI(vec_est=.summary_betas_slope_SP[,1],
vec_stderr=.summary_betas_slope_SP[,2],
vec_true=rep(minimal_change_baseline, nrow(.summary_betas_slope_SP)))
}else{
.params_in_ci <- give_params_in_CI(vec_est=.summary_betas_slope_SP[1],
vec_stderr=.summary_betas_slope_SP[2],
vec_true=minimal_change_baseline)
}
.params_in_ci <- sapply(1:length(.params_in_ci), function(i){
## for the ones in which there is a change, say whether it's up- or down-regulated
if(!.params_in_ci[i]){
## if there is a change: not in confidence interval
if(is.null(dim(.summary_betas_slope_SP))){
## one-dim
if(.summary_betas_slope_SP[1] > minimal_change_baseline){
'increase'
}else{
'decrease'
}
}else{
## multi-dim
if(.summary_betas_slope_SP[i,1] > minimal_change_baseline){
'increase'
}else{
'decrease'
}
}
}else{
'FALSE'
}
})
if(!is.null(df_betas)){
.baseline <- NA
}else{
names(.params_in_ci) <- sapply(logR_names_vec[[idx_sp]], function(i) strsplit(i, '/')[[1]][1])
.baseline <- strsplit(logR_names_vec[[idx_sp]][[1]], '/')[[1]][2]
}
return(list(betas_perturbed=.params_in_ci, baseline=.baseline))
}
comparison_betas_models <- function(model_fullRE_DMSL_list, model_diagRE_DMSL_list, model_fullRE_M_list ){
.x <- do.call('rbind.data.frame', lapply(enough_samples, function(ct){
x_beta_fullRE_DMSL <- try(python_like_select_name(model_fullRE_DMSL_list[[ct]]$par.fixed, "beta"))
x_beta_diagRE_DMSL <- try(python_like_select_name(model_diagRE_DMSL_list[[ct]]$par.fixed, "beta"))
x_beta_fullRE_M <- try(python_like_select_name(model_fullRE_M_list[[ct]]$par.fixed, "beta"))
if( (length(x_beta_fullRE_DMSL) != length(x_beta_diagRE_DMSL)) | (length(x_beta_fullRE_DMSL) != length(x_beta_fullRE_M)) ){
## if we don't have results for any, remove from the analysis
list_betas <- list(x_beta_fullRE_DMSL, x_beta_diagRE_DMSL, x_beta_fullRE_M)
typeofs_of_betas <- sapply(list_betas, typeof)
if( all(typeofs_of_betas == "character")  ){
return(NULL)
}else{
## if we do have results for some, replace the error message by an NA string
## replace using the length of the first double entry
if(typeofs_of_betas[1] == "character"){
x_beta_fullRE_DMSL <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
}
if(typeofs_of_betas[2] == "character"){
x_beta_diagRE_DMSL <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
}
if(typeofs_of_betas[3] == "character"){
x_beta_fullRE_M <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
}
if( (length(x_beta_fullRE_DMSL) != length(x_beta_diagRE_DMSL)) | (length(x_beta_fullRE_DMSL) != length(x_beta_fullRE_M)) ){
warning(paste0(ct, ': the number of log-ratios is not consistent'))
return(NULL)
}
}
}
cbind.data.frame(rbind.data.frame(
cbind.data.frame(fullRE_DMSL=select_slope_2(x_beta_fullRE_DMSL),
diagRE_DMSL=select_slope_2(x_beta_diagRE_DMSL),
fullRE_M=select_slope_2(x_beta_fullRE_M),
beta_type='Slope'),
cbind.data.frame(fullRE_DMSL=select_intercept(x_beta_fullRE_DMSL),
diagRE_DMSL=select_intercept(x_beta_diagRE_DMSL),
fullRE_M=select_intercept(x_beta_fullRE_M),
beta_type='Intercept')),
ct=ct)
}
))
## if something hasn't converged, remove the value
bad_ct_fullRE_DMSL <- c(enough_samples[sapply(enough_samples,
function(ct) (typeof(model_fullRE_DMSL_list[[ct]])) == 'character')],
enough_samples[sapply(enough_samples,
function(ct)  try(model_fullRE_DMSL_list[[ct]]$pdHess)) != "TRUE"])
bad_ct_diagRE_DMSL <- c(enough_samples[sapply(enough_samples,
function(ct) (typeof(model_diagRE_DMSL_list[[ct]])) == 'character')],
enough_samples[sapply(enough_samples, function(ct)  try(model_diagRE_DMSL_list[[ct]]$pdHess)) != "TRUE"])
bad_ct_fullRE_M <- c(enough_samples[sapply(enough_samples,
function(ct) (typeof(model_fullRE_M_list[[ct]])) == 'character')],
enough_samples[sapply(enough_samples, function(ct)  try(model_fullRE_M_list[[ct]]$pdHess)) != "TRUE"])
.x$fullRE_DMSL[(.x$ct %in% bad_ct_fullRE_DMSL)] = NA
.x$diagRE_DMSL[(.x$ct %in% bad_ct_diagRE_DMSL)] = NA
.x$fullRE_M[(.x$ct %in% bad_ct_fullRE_M)] = NA
.x$ct2=renaming_pcawg[,2][match(.x$ct, renaming_pcawg[,1])]
return(.x)
}
comparison_betas_models2 <- function(model_fullRE_DMSL_list, model_diagRE_DMDL_list, model_fullRE_M_list ){
## with model_diagRE_DMDL_list instead of model_diagRE_DMSL_list
.x <- do.call('rbind.data.frame', lapply(enough_samples, function(ct){
x_beta_fullRE_DMSL <- try(python_like_select_name(model_fullRE_DMSL_list[[ct]]$par.fixed, "beta"))
x_beta_diagRE_DMDL <- try(python_like_select_name(model_diagRE_DMDL_list[[ct]]$par.fixed, "beta"))
x_beta_fullRE_M <- try(python_like_select_name(model_fullRE_M_list[[ct]]$par.fixed, "beta"))
if( (length(x_beta_fullRE_DMSL) != length(x_beta_diagRE_DMDL)) | (length(x_beta_fullRE_DMSL) != length(x_beta_fullRE_M)) ){
## if we don't have results for any, remove from the analysis
list_betas <- list(x_beta_fullRE_DMSL, x_beta_diagRE_DMDL, x_beta_fullRE_M)
typeofs_of_betas <- sapply(list_betas, typeof)
if( all(typeofs_of_betas == "character")  ){
return(NULL)
}else{
## if we do have results for some, replace the error message by an NA string
## replace using the length of the first double entry
if(typeofs_of_betas[1] == "character"){
x_beta_fullRE_DMSL <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
}
if(typeofs_of_betas[2] == "character"){
x_beta_diagRE_DMDL <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
}
if(typeofs_of_betas[3] == "character"){
x_beta_fullRE_M <- rep(NA, length(list_betas[[which(typeofs_of_betas == "double")[1]]]))
}
if( (length(x_beta_fullRE_DMSL) != length(x_beta_diagRE_DMDL)) | (length(x_beta_fullRE_DMSL) != length(x_beta_fullRE_M)) ){
warning(paste0(ct, ': the number of log-ratios is not consistent'))
return(NULL)
}
}
}
cbind.data.frame(rbind.data.frame(
cbind.data.frame(fullRE_DMSL=select_slope_2(x_beta_fullRE_DMSL),
diagRE_DMDL=select_slope_2(x_beta_diagRE_DMDL),
fullRE_M=select_slope_2(x_beta_fullRE_M),
beta_type='Slope'),
cbind.data.frame(fullRE_DMSL=select_intercept(x_beta_fullRE_DMSL),
diagRE_DMDL=select_intercept(x_beta_diagRE_DMDL),
fullRE_M=select_intercept(x_beta_fullRE_M),
beta_type='Intercept')),
ct=ct)
}
))
## if something hasn't converged, remove the value
bad_ct_fullRE_DMSL <- c(enough_samples[sapply(enough_samples,
function(ct) (typeof(model_fullRE_DMSL_list[[ct]])) == 'character')],
enough_samples[sapply(enough_samples,
function(ct)  try(model_fullRE_DMSL_list[[ct]]$pdHess)) != "TRUE"])
bad_ct_diagRE_DMDL <- c(enough_samples[sapply(enough_samples,
function(ct) (typeof(model_diagRE_DMDL_list[[ct]])) == 'character')],
enough_samples[sapply(enough_samples, function(ct)  try(model_diagRE_DMDL_list[[ct]]$pdHess)) != "TRUE"])
bad_ct_fullRE_M <- c(enough_samples[sapply(enough_samples,
function(ct) (typeof(model_fullRE_M_list[[ct]])) == 'character')],
enough_samples[sapply(enough_samples, function(ct)  try(model_fullRE_M_list[[ct]]$pdHess)) != "TRUE"])
.x$fullRE_DMSL[(.x$ct %in% bad_ct_fullRE_DMSL)] = NA
.x$diagRE_DMDL[(.x$ct %in% bad_ct_diagRE_DMDL)] = NA
.x$fullRE_M[(.x$ct %in% bad_ct_fullRE_M)] = NA
.x$ct2=renaming_pcawg[,2][match(.x$ct, renaming_pcawg[,1])]
return(.x)
}
L_to_cov <- function(cov_vector, d){
warning('This function was wrong until 20220316. L is a lower triangular matrix, not a symmetrical matrix')
L <- fill_covariance_matrix(arg_d = d, arg_entries_var = rep(1, d), arg_entries_cov = cov_vector)
L[upper.tri(L)] <- 0
D <- diag(L%*%t(L))
diag((D)**(-1/2)) %*% L %*% t(L) %*% diag((D)**(-1/2))
}
comparison_randomintercepts_models <- function(model_fullRE_DMSL_list, model_diagRE_DMDL_list, model_fullRE_M_list ){
.x <- do.call('rbind.data.frame', lapply(enough_samples, function(ct){
x_RE_fullRE_DMSL <- try(python_like_select_name(model_fullRE_DMSL_list[[ct]]$par.random, "u_large"))
x_RE_diagRE_DMDL <- try(python_like_select_name(model_diagRE_DMDL_list[[ct]]$par.random, "u_large"))
x_RE_fullRE_M <- try(python_like_select_name(model_fullRE_M_list[[ct]]$par.random, "u_large"))
if( (length(x_RE_fullRE_DMSL) != length(x_RE_diagRE_DMDL)) | (length(x_RE_fullRE_DMSL) != length(x_RE_fullRE_M)) ){
## if we don't have results for any, remove from the analysis
list_RE <- list(x_RE_fullRE_DMSL, x_RE_diagRE_DMDL, x_RE_fullRE_M)
typeofs_of_RE <- sapply(list_RE, typeof)
if( all(typeofs_of_RE == "character")  ){
return(NULL)
}else{
## if we do have results for some, replace the error message by an NA string
## replace using the length of the first double entry
if(typeofs_of_RE[1] == "character"){
x_RE_fullRE_DMSL <- rep(NA, length(list_RE[[which(typeofs_of_RE == "double")[1]]]))
}
if(typeofs_of_RE[2] == "character"){
x_RE_diagRE_DMSL <- rep(NA, length(list_RE[[which(typeofs_of_RE == "double")[1]]]))
}
if(typeofs_of_RE[3] == "character"){
x_RE_fullRE_M <- rep(NA, length(list_RE[[which(typeofs_of_RE == "double")[1]]]))
}
if( (length(x_RE_fullRE_DMSL) != length(x_RE_diagRE_DMDL)) | (length(x_RE_fullRE_DMSL) != length(x_RE_fullRE_M)) ){
warning(paste0(ct, ': the number of log-ratios is not consistent'))
return(NULL)
}
}
}
## put the coefficients in matrix form
## get the number of log-ratios, d-1
dmin1 <- (names(table(sapply(list(model_fullRE_DMSL_list, model_diagRE_DMDL_list, model_fullRE_M_list), function(i)    as.numeric(try(length(python_like_select_name(i[[ct]]$par.fixed, 'beta'))/2))))))
if(length(dmin1) == 1){
## there should only be one, shared, d-1
dmin1 <- as.numeric(dmin1)
}else{
stop(paste0('Models do not agree on number of log-ratios. CT: ', ct))
}
x_RE_fullRE_DMSL <- matrix(x_RE_fullRE_DMSL, ncol=dmin1, byrow=F)
x_RE_diagRE_DMDL <- matrix(x_RE_diagRE_DMDL, ncol=dmin1, byrow=F)
x_RE_fullRE_M <- matrix(x_RE_fullRE_M, ncol=dmin1, byrow=F)
bad_fullRE_DMSL=F
bad_diagRE_DMDL=F
bad_fullRE_M=F
## if something hasn't converged, set all the random coefficients to NA
if((typeof(model_fullRE_DMSL_list[[ct]]) == "character") ){
bad_fullRE_DMSL=T
}else{
if(try(!(model_fullRE_DMSL_list[[ct]]$pdHess))){
bad_fullRE_DMSL=T
}
}
if(bad_fullRE_DMSL){
x_RE_fullRE_DMSL <- matrix(NA, nrow = nrow(x_RE_fullRE_DMSL), ncol=ncol(x_RE_fullRE_DMSL))
}
#----
if((typeof(model_diagRE_DMDL_list[[ct]]) == "character") ){
bad_diagRE_DMDL=T
}else{
if(try(!(model_diagRE_DMDL_list[[ct]]$pdHess))){
bad_diagRE_DMDL=T
}
}
if(bad_diagRE_DMDL){
x_RE_diagRE_DMDL <- matrix(NA, nrow = nrow(x_RE_diagRE_DMDL), ncol=ncol(x_RE_diagRE_DMDL))
}
#-----
if((typeof(model_fullRE_M_list[[ct]]) == "character") ){
bad_fullRE_M=T
}else{
if(try(!(model_fullRE_M_list[[ct]]$pdHess))){
bad_fullRE_M=T
}
}
if(bad_fullRE_M){
x_RE_fullRE_M <- matrix(NA, nrow = nrow(x_RE_fullRE_M), ncol=ncol(x_RE_fullRE_M))
}
## for each patient using the x_RE_fullRE_DMSL intercepts, get the distance to the intercepts of the other two models
dist_DMSLs <- sapply(1:nrow(x_RE_fullRE_DMSL), function(i){
if(all(is.na(x_RE_fullRE_DMSL[i,])) | all(is.na(x_RE_diagRE_DMDL[i,]))){
NA
}else{
dist(rbind(x_RE_fullRE_DMSL[i,], x_RE_diagRE_DMDL[i,]))
}
})
dist_fullREs <- sapply(1:nrow(x_RE_fullRE_DMSL), function(i){
if(all(is.na(x_RE_fullRE_DMSL[i,])) | all(is.na(x_RE_fullRE_M[i,]))){
NA
}else{
dist(rbind(x_RE_fullRE_DMSL[i,], x_RE_fullRE_M[i,]))
}
})
cbind.data.frame(melt(list(dist_DMSLs=dist_DMSLs, dist_fullREs=dist_fullREs)),
ct=ct)
}
))
.x$ct2=renaming_pcawg[,2][match(.x$ct, renaming_pcawg[,1])]
return(.x)
}
give_first_col <- function(i){
if(is.null(dim(i))){i[1]}else{i[,1]}
}
give_pairs_with_mvn <- function(mat_mvn, lims=NULL){
require(car)
if(is.null(lims)){
dataEllipse(mat_mvn[,1], mat_mvn[,2], levels=c(0.95), xlim=c(min(mat_mvn[,1])-1,max(mat_mvn[,1])+1),
ylim=c(min(mat_mvn[,2])-1,max(mat_mvn[,2])+1))
}else{
dataEllipse(mat_mvn[,1], mat_mvn[,2], levels=c(0.95), xlim=lims,
ylim=lims)
}
}
remove_all_NA <- function(i) i[!(colSums(apply(i, 1, is.na)) > 0),]
give_pairs_with_mvn_wrapper <- function(exposures_arg, zero_to_NA=F, common_lims=F){
if(zero_to_NA){
exposures_arg[exposures_arg == 0] <- NA
}
common_lims_vec <- c(min(exposures_arg, na.rm=T), max(exposures_arg, na.rm=T))
par(mfrow=c(ncol(exposures_arg), ncol(exposures_arg)), mar=c(0,0,0,0))
for(ii in 1:ncol(exposures_arg)){
for(jj in 1:ncol(exposures_arg)){
if(ii != jj){
if(common_lims){
give_pairs_with_mvn(remove_all_NA(exposures_arg[,c(ii, jj)]), lims=common_lims_vec)
}else{
give_pairs_with_mvn(remove_all_NA(exposures_arg[,c(ii, jj)]))
}
}else{plot.new()}
}
}
}
adjust_all <- function(i, new_version=F, method='BH'){
if(!new_version){
if(method != "holm"){
stop('by default, in the past, using SNV, the default method has been holm')
}
stopifnot(colnames(i)[ncol(i)] == "true")
cbind.data.frame(apply(i[,-ncol(i)], 2, p.adjust), true=i[,ncol(i)])
}else{
cbind.data.frame(apply(i[,colnames(i) != "true"], 2, p.adjust, method=method), true=i[,colnames(i) == "true"])
}
}
color_list <- c("dodgerblue2", "coral2", "burlywood2", "blue1", "darkseagreen1", "firebrick", "goldenrod1", "firebrick3", "darkolivegreen3",
"darkmagenta", "white", "darkolivegreen2", "antiquewhite", "antiquewhite1", "antiquewhite2", "antiquewhite3", "antiquewhite4",
"aquamarine", "aquamarine1", "aquamarine2", "aquamarine3", "aquamarine4", "azure", "azure1",
"azure2", "azure3", "azure4", "beige", "bisque", "bisque1", "bisque2",
"bisque3", "bisque4", "black", "blanchedalmond", "blue", "blue1", "blue2")
# [29] "blue3", "blue4", "blueviolet"      "brown", "brown1", "brown2", "brown3", "aliceblue"
# [36] "brown4", "burlywood"       "burlywood1", "burlywood3"      "burlywood4"      "cadetblue",
# [43] "cadetblue1"      "cadetblue2"      "cadetblue3", "cadetblue4", "chartreuse", "chartreuse1", "chartreuse2",
# [50] "chartreuse3"     "chartreuse4", "chocolate", "chocolate1", "chocolate2", "chocolate3", "chocolate4",
# [57] "coral", "coral1"          "coral2", "coral3", "coral4", "cornflowerblue"  "cornsilk",
# [64] "cornsilk1", "cornsilk2", "cornsilk3", "cornsilk4"       "cyan", "cyan1", "cyan2",
# [71] "cyan3", "cyan4", "darkblue", "darkcyan", "darkgoldenrod"   "darkgoldenrod1"  "darkgoldenrod2",
# [78] "darkgoldenrod3"  "darkgoldenrod4"  "darkgray"        "darkgreen"       "darkgrey"        "darkkhaki",
# [85] "darkolivegreen"  "darkolivegreen1"  "darkolivegreen4" "darkorange"      "darkorange1",
# [92] "darkorange2", "darkorange3", "darkorange4", "darkorchid"      "darkorchid1"     "darkorchid2"     "darkorchid3",
# [99] "darkorchid4"     "darkred", "darksalmon", "darkseagreen"    ""   "darkseagreen2"   "darkseagreen3",
# [106] "darkseagreen4"   "darkslateblue"   "darkslategray"   "darkslategray1"  "darkslategray2"  "darkslategray3"  "darkslategray4",
# [113] "darkslategrey"   "darkturquoise"   "darkviolet", "deeppink", "deeppink1"       "deeppink2"       "deeppink3",
# [120] "deeppink4", "deepskyblue"     "deepskyblue1", "deepskyblue2", "deepskyblue3"    "deepskyblue4"    "dimgray",
# [127] "dimgrey", "dodgerblue", "dodgerblue1", "dodgerblue2"     "dodgerblue3"     "dodgerblue4"     "firebrick",
# [134] "firebrick2", "firebrick4"      "floralwhite"     "forestgreen"     "gainsboro",
# [141] "ghostwhite"      "gold"            "gold1"           "gold2"           "gold3"           "gold4"           "goldenrod",
# [148] "goldenrod1"      "goldenrod2"      "goldenrod3"      "goldenrod4"      "gray"            "gray0")
logR_coef_names = c('chr1', vector_cats_to_logR(c(unique(rownames(object_for_DA$Y))[-1], 'chr1'), sep = '-'))
logR_sigs = vector_cats_to_logR(colnames(object_for_DA$Y))
plt_chrom <- plot_betas(chrom_FEREDMsinglelambda, num_covariates = ncol(object_for_DA$x),
names_cats = logR_sigs, labels_betas=logR_coef_names, keep_order_signatures = T,
keep_order_covariates = T, return_ggplot = T, return_plot = F, plot = F)
plt_chrom+labs(x='Signature log-ratios', y=latex2exp::TeX(r"($\hat{\beta}$)"))
ggsave("../../../../results/additional_use_cases/chromosomes_FE_singlelambda_betas.pdf", height = 8, width = 8.5)
ggsave("../../../../results/additional_use_cases/chromosomes_FE_singlelambda_betas.png", height = 8, width = 8.5)
betas_df <- plot_betas(chrom_FEREDMsinglelambda, num_covariates = ncol(object_for_DA$x),
names_cats = logR_sigs, labels_betas=logR_coef_names, keep_order_signatures = T,
keep_order_covariates = T, return_df = T)
betas_mat = dcast(betas_df[,-2], value.var='Estimate', type_beta~LogR)
rownames(betas_mat) <- betas_mat[,1]; betas_mat[,1] <- NULL
betas_cor <- outer(1:nrow(betas_mat), 1:nrow(betas_mat), Vectorize(function(x,y){
cor(t(betas_mat[x,]), t(betas_mat[y,]))
}))
cor_plot <- pheatmap::pheatmap(betas_cor,   color = colorRampPalette(c("#5FFBF1", "#86A8E7", "#D16BA5"))(100))
cor_plot
betas_df <- plot_betas(chrom_FEREDMsinglelambda, num_covariates = ncol(object_for_DA$x),
names_cats = logR_sigs, labels_betas=logR_coef_names, keep_order_signatures = T,
keep_order_covariates = T, return_df = T)
betas_mat = dcast(betas_df[,-2], value.var='Estimate', type_beta~LogR)
rownames(betas_mat) <- betas_mat[,1]; betas_mat[,1] <- NULL
betas_cor <- outer(1:nrow(betas_mat), 1:nrow(betas_mat), Vectorize(function(x,y){
cor(t(betas_mat[x,]), t(betas_mat[y,]))
}))
cor_plot <- pheatmap::pheatmap(betas_cor,   color = colorRampPalette(c("#5FFBF1", "#86A8E7", "#D16BA5"))(100))
cor_plot
betas_cor
betas_mat
rownames(betas_cor) <- colnames(betas_cor) <- rownames(betas_mat)
cor_plot <- pheatmap::pheatmap(betas_cor,   color = colorRampPalette(c("#5FFBF1", "#86A8E7", "#D16BA5"))(100))
cor_plot
##------------------------------------------------------------------------------------------##
colnames(betas_cor) <- rownames(betas_cor) <- rownames(betas_mat)
pdf("../../../../results/additional_use_cases/chromosomes_FE_singlelambda_betas_cor.pdf",
height = 5, width = 5.5)
print(cor_plot)
dev.off()
png("../../../../results/additional_use_cases/chromosomes_FE_singlelambda_betas_cor.png",
height = 5, width = 5.5, units = 'in', res=300)
print(cor_plot)
dev.off()
